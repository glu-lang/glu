import allocation::{allocate, deallocate};
import io::snprintf;
import operators::*;

public import stringType::*;

@no_mangling
func strlen(s: *Char) -> Int;

@no_mangling
func memcmp(s1: *Char, s2: *Char, n: Int) -> Int;

@no_mangling
func memcpy(dst: *Char, src: *Char, n: Int) -> *Char;

func createNullTerminatedCopy(s: String) -> *Char {
    var buffer: *Char = allocate(s.length + 1);
    memcpy(buffer, s.data, s.length);
    memcpy(&buffer[s.length as UInt64], "\0" as *Char, 1);
    return buffer;
}

@no_mangling
func abort();

@no_mangling
public func atoi(s: *Char) -> Int;

@no_mangling
public func atof(s: *Char) -> Float;

func createStringFromPointer(s: *Char, length: Int, allocated: Bool) -> String {
    var str: String;

    str.data = s;
    str.length = length;
    str.isAllocated = allocated;

    return str;
}

public func compare(s1: String, s2: String) -> Int {
    var minLength: Int = s1.length < s2.length ? s1.length : s2.length;
    var cmp: Int = memcmp(s1.data, s2.data, minLength);
    if (cmp != 0) {
        return cmp;
    }
    return s1.length - s2.length;
}

public func compare(s1: String, s2: *Char) -> Int {
    var s2Len: Int = strlen(s2);
    var minLength: Int = s1.length < s2Len ? s1.length : s2Len;
    var cmp: Int = memcmp(s1.data, s2, minLength);
    if (cmp != 0) {
        return cmp;
    }
    return s1.length - s2Len;
}

public func compare(s1: *Char, s2: String) -> Int {
    return -(compare(s2, s1));
}

public func strlen(s: String) -> Int {
    return s.length;
}

public func +(lhs: String, rhs: String) -> String {
    var result: *Char = allocate(lhs.length + rhs.length + 1);
    memcpy(result, lhs.data, lhs.length);
    memcpy(&result[lhs.length as UInt64], rhs.data, rhs.length);
    return createStringFromPointer(result, lhs.length + rhs.length, true);
}

public func stringIsEmpty(s: String) -> Bool {
    return s.length == 0;
}

func <=(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) <= (rhs as UInt8);
}

func <(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) < (rhs as UInt8);
}

func >(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) > (rhs as UInt8);
}

public func ==(lhs: String, rhs: String) -> Bool {
    if (lhs.length != rhs.length) {
        return false;
    }
    if (lhs.length == 0) {
        return true;
    }
    return memcmp(lhs.data, rhs.data, lhs.length) == 0;
}

public func !=(lhs: String, rhs: String) -> Bool {
    return !(lhs == rhs);
}

public func <(lhs: String, rhs: String) -> Bool {
    return compare(lhs, rhs) < 0;
}

public func <=(lhs: String, rhs: String) -> Bool {
    return compare(lhs, rhs) <= 0;
}

public func >(lhs: String, rhs: String) -> Bool {
    return compare(lhs, rhs) > 0;
}

public func >=(lhs: String, rhs: String) -> Bool {
    return compare(lhs, rhs) >= 0;
}

public func stringSubstring(s: String, start: Int, end: Int) -> String {
    var result: String;
    if (start < 0 || end < start || end > s.length) {
        result.data = null;
        result.length = 0;
        result.isAllocated = false;
        return result;
    }
    var length: Int = end - start;
    result.data = allocate(length);
    memcpy(result.data, &s.data[start as UInt64], length);
    result.length = length;
    result.isAllocated = true;
    return result;
}

public func [](s: String, index: Int) -> Char {
    if (index < 0 || s.length <= index) {
        abort();
    }
    return s.data[index as UInt64] as Char;
}

public func stringSlice(s: String, start: Int, length: Int) -> String {
    if (start < 0 || length < 0 || start >= s.length || length == 0) {
        return createStringFromPointer(null, 0, false);
    }
    var actualLength: Int = length;
    if (start + length > s.length) {
        actualLength = s.length - start;
    }
    var str: *Char = allocate(actualLength);
    memcpy(str, &s.data[start as UInt64], actualLength);
    return createStringFromPointer(str, actualLength, true);
}

public func stringIndexOf(s: String, substr: String) -> Int {
    if (substr.length == 0) {
        return 0;
    }
    if (s.length < substr.length) {
        return -(1 as Int);
    }

    var firstChar: Char = substr.data[0] as Char;
    var i: Int = 0;

    while (i <= s.length - substr.length) {
        if (s.data[i as UInt64] as Char == firstChar) {
            if (substr.length == 1) {
                return i;
            }

            if (memcmp(&s.data[i as UInt64], substr.data, substr.length) == 0) {
                return i;
            }
        }
        i = i + 1;
    }

    return -(1 as Int);
}

public func stringLastIndexOf(s: String, substr: String) -> Int {
    if (substr.length == 0) {
        return s.length;
    }
    if (s.length < substr.length) {
        return -(1 as Int);
    }

    // Optimized: start from the end and use memcmp
    var firstChar: Char = substr.data[0] as Char;
    var i: Int = s.length - substr.length;

    while (i >= 0) {
        // Quick check: compare first character first
        if (s.data[i as UInt64] as Char == firstChar) {
            // If substring is length 1, we found it
            if (substr.length == 1) {
                return i;
            }

            // Use memcmp for efficient comparison
            if (memcmp(&s.data[i as UInt64], substr.data, substr.length) == 0) {
                return i;
            }
        }
        i = i - 1;
    }
    return -(1 as Int);
}

public func stringContains(s: String, substr: String) -> Bool {
    return stringIndexOf(s, substr) != -(1 as Int);
}

public func stringReverse(s: String) -> String {
    var str: *Char = allocate(s.length);
    var i: Int = 0;

    while (i < s.length) {
        str[i as UInt64] = s.data[(s.length - i - 1) as UInt64];
        i = i + 1;
    }
    return createStringFromPointer(str, s.length, true);
}

public func stringToUpper(s: String) -> String {
    var str: *Char = allocate(s.length);

    memcpy(str, s.data, s.length);

    var i: Int = 0;
    while (i < s.length) {
        var c: Char = str[i as UInt64];
        if ("a" <= c && c <= "z") {
            str[i as UInt64] = ((c as Int) - 32) as Char;
        }
        i = i + 1;
    }

    return createStringFromPointer(str, s.length, true);
}

public func stringToLower(s: String) -> String {
    var str: *Char = allocate(s.length);

    memcpy(str, s.data, s.length);

    var i: Int = 0;
    while (i < s.length) {
        var c: Char = str[i as UInt64];
        if ("A" <= c && c <= "Z") {
            str[i as UInt64] = ((c as Int) + 32) as Char;
        }
        i = i + 1;
    }

    return createStringFromPointer(str, s.length, true);
}

public func stringTrim(s: String) -> String {
    if (s.length == 0) {
        return s;
    }

    var start: Int = 0;
    var end: Int = s.length - 1;

    // Find first non-space character
    while (start <= end && (s.data[start as UInt64] == " " || s.data[start as UInt64]== "\n" || s.data[start as UInt64] == "\t")) {
        start = start + 1;
    }

    // Find last non-space character
    while (end >= start && (s.data[end as UInt64] == " " || s.data[end as UInt64] == "\n" || s.data[end as UInt64] == "\t")) {
        end = end - 1;
    }

    // Create trimmed string
    var newLength: Int = end - start + 1;
    if (newLength <= 0) {
        return createStringFromPointer(null, 0, false);
    }
    var str: *Char = allocate(newLength);
    memcpy(str, &s.data[start as UInt64], newLength);
    return createStringFromPointer(str, newLength, true);
}

public func stringReplace(s: String, from: String, to: String) -> String {
    if (from.length == 0 || s.length == 0 || from.length > s.length) {
        return s;
    }

    // Optimized: Count occurrences using memcmp
    var firstChar: Char = from.data[0] as Char;
    var count: Int = 0;
    var i: Int = 0;

    while (i <= s.length - from.length) {
        if (s.data[i as UInt64] as Char == firstChar) {
            if (from.length == 1 || memcmp(&s.data[i as UInt64], from.data, from.length) == 0) {
                count = count + 1;
                i = i + from.length;
            } else {
                i = i + 1;
            }
        } else {
            i = i + 1;
        }
    }

    // If no occurrences, return original
    if (count == 0) {
        return s;
    }

    var newLength: Int = s.length - (count * from.length) + (count * to.length);

    // Handle case where result would be empty
    if (newLength == 0) {
        return createStringFromPointer(null, 0, false);
    }

    var str: *Char = allocate(newLength);

    i = 0;
    var resultPos: Int = 0;
    while (i < s.length) {
        // Check if we have a match at current position
        var match: Bool = false;
        if (i <= s.length - from.length) {
            if (s.data[i as UInt64] as Char == firstChar) {
                if (from.length == 1 || memcmp(&s.data[i as UInt64], from.data, from.length) == 0) {
                    match = true;
                }
            }
        }

        if (match) {
            // Copy 'to' string using memcpy if possible
            if (to.length > 0) {
                memcpy(&str[resultPos as UInt64], to.data, to.length);
            }
            resultPos = resultPos + to.length;
            i = i + from.length;
        } else {
            // Copy original character
            str[resultPos as UInt64] = s.data[i as UInt64];
            resultPos = resultPos + 1;
            i = i + 1;
        }
    }

    return createStringFromPointer(str, newLength, true);
}

public func stringToInt(s: String) -> Int {
    var nullTerminated: *Char = createNullTerminatedCopy(s);
    var result: Int = atoi(nullTerminated);
    deallocate(nullTerminated);
    return result;
}

public func stringToFloat(s: String) -> Float {
    var nullTerminated: *Char = createNullTerminatedCopy(s);
    var result: Float = atof(nullTerminated);
    deallocate(nullTerminated);
    return result;
}

public func intToString(n: Int) -> String {
    let length: Int = snprintf(null, 0, "%d", n);
    var buffer: *Char = allocate(length + 1);
    snprintf(buffer, length + 1, "%d", n);
    return createStringFromPointer(buffer, length, true);
}

public func floatToString(f: Float) -> String {
    let length: Int = snprintf(null, 0, "%f", f);
    var buffer: *Char = allocate(length + 1);
    snprintf(buffer, length + 1, "%f", f);
    return createStringFromPointer(buffer, length, true);
}
