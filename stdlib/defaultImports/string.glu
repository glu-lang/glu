import allocation::{allocate, deallocate, alloc_box, retain_box, release_box};
import io::snprintf;
import operators::*;

public import stringType::*;

@no_mangling
func strlen(s: *Char) -> Int;

@no_mangling
func memcmp(s1: *Char, s2: *Char, n: Int) -> Int;

@no_mangling
func memcpy(dst: *Char, src: *Char, n: Int) -> *Char;

func createNullTerminatedCopy(s: String) -> *Char {
    var buffer: *Char = allocate(s.length + 1);

    memcpy(buffer, s.data, s.length);
    buffer[s.length] = "\u0000";
    return buffer;
}

@no_mangling
func abort();

@no_mangling
public func atoi(s: *Char) -> Int;

@no_mangling
public func atof(s: *Char) -> Float;

func createStringFromPointer(s: *Char, length: Int, allocated: Bool) -> String {
    return { s, length, allocated };
}

public func compare(s1: String, s2: String) -> Int {
    let minLength: Int = s1.length < s2.length ? s1.length : s2.length;
    let cmp: Int = memcmp(s1.data, s2.data, minLength);

    return cmp != 0 ? cmp : s1.length - s2.length;
}

public func compare(s1: String, s2: *Char) -> Int {
    let s2Len: Int = strlen(s2);
    let minLength: Int = s1.length < s2Len ? s1.length : s2Len;
    let cmp: Int = memcmp(s1.data, s2, minLength);

    return cmp != 0 ? cmp : s1.length - s2Len;
}

public func compare(s1: *Char, s2: String) -> Int {
    return -(compare(s2, s1));
}

public func strlen(s: String) -> Int {
    return s.length;
}

public func +(lhs: String, rhs: String) -> String {
    var result: *Char = allocate(lhs.length + rhs.length + 1);

    memcpy(result, lhs.data, lhs.length);
    memcpy(&result[lhs.length], rhs.data, rhs.length);
    return createStringFromPointer(result, lhs.length + rhs.length, true);
}

public func stringIsEmpty(s: String) -> Bool {
    return s.length == 0;
}

func <=(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) <= (rhs as UInt8);
}

func <(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) < (rhs as UInt8);
}

func >(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) > (rhs as UInt8);
}

public func ==(lhs: String, rhs: String) -> Bool {
    if (lhs.length != rhs.length) {
        return false;
    }

    if (lhs.length == 0) {
        return true;
    }

    return memcmp(lhs.data, rhs.data, lhs.length) == 0;
}

public func !=(lhs: String, rhs: String) -> Bool {
    return !(lhs == rhs);
}

public func <(lhs: String, rhs: String) -> Bool {
    return compare(lhs, rhs) < 0;
}

public func <=(lhs: String, rhs: String) -> Bool {
    return compare(lhs, rhs) <= 0;
}

public func >(lhs: String, rhs: String) -> Bool {
    return compare(lhs, rhs) > 0;
}

public func >=(lhs: String, rhs: String) -> Bool {
    return compare(lhs, rhs) >= 0;
}

public func stringSubstring(s: String, start: Int, end: Int) -> String {
    if (start < 0 || end < start || end > s.length) {
        return "";
    }

    let length: Int = end - start;

    if (!s.isAllocated) {
        return createStringFromPointer(&s.data[start], length, false);
    }

    var str: *Char = alloc_box(length);

    memcpy(str, &s.data[start], length);
    return createStringFromPointer(str, length, true);
}

public func [](s: String, index: Int) -> Char {
    if (index < 0 || s.length <= index) {
        abort();
    }

    return s.data[index];
}

public func stringSlice(s: String, start: Int, length: Int) -> String {
    if (start < 0 || length <= 0 || start >= s.length) {
        return "";
    }

    let actualLength: Int = start + length > s.length ? s.length - start : length;
    return stringSubstring(s, start, start + actualLength);
}

public func stringIndexOf(s: String, substr: String) -> Int {
    if (substr.length == 0) {
        return 0;
    }

    if (s.length < substr.length) {
        return -1;
    }

    let firstChar: Char = substr.data[0];
    var i: Int = 0;

    while (i <= s.length - substr.length) {
        if (s.data[i] == firstChar) {
            if (substr.length == 1) {
                return i;
            }

            if (memcmp(&s.data[i], substr.data, substr.length) == 0) {
                return i;
            }
        }
        i = i + 1;
    }

    return -1;
}

public func stringLastIndexOf(s: String, substr: String) -> Int {
    if (substr.length == 0) {
        return s.length;
    }

    if (s.length < substr.length) {
        return -1;
    }

    // Optimized: start from the end and use memcmp
    let firstChar: Char = substr.data[0];
    var i: Int = s.length - substr.length;

    while (i >= 0) {
        // Quick check: compare first character first
        if (s.data[i] == firstChar) {
            // If substring is length 1, we found it
            if (substr.length == 1) {
                return i;
            }

            // Use memcmp for efficient comparison
            if (memcmp(&s.data[i], substr.data, substr.length) == 0) {
                return i;
            }
        }
        i = i - 1;
    }

    return -1;
}

public func stringContains(s: String, substr: String) -> Bool {
    return stringIndexOf(s, substr) != -1;
}

public func stringReverse(s: String) -> String {
    var str: *Char = alloc_box(s.length);
    var i: Int = 0;

    while (i < s.length) {
        str[i] = s.data[(s.length - i - 1)];
        i = i + 1;
    }

    return createStringFromPointer(str, s.length, true);
}

public func stringToUpper(s: String) -> String {
    var str: *Char = alloc_box(s.length);
    memcpy(str, s.data, s.length);

    var i: Int = 0;
    while (i < s.length) {
        if ("a" <= str[i] && str[i] <= "z") {
            str[i] = (str[i] - 32) as Char;
        }
        i = i + 1;
    }

    return createStringFromPointer(str, s.length, true);
}

public func stringToLower(s: String) -> String {
    var str: *Char = alloc_box(s.length);
    memcpy(str, s.data, s.length);

    var i: Int = 0;
    while (i < s.length) {
        if ("A" <= str[i] && str[i] <= "Z") {
            str[i] = (str[i] + 32) as Char;
        }
        i = i + 1;
    }

    return createStringFromPointer(str, s.length, true);
}

public func stringTrim(s: String) -> String {
    if (s.length == 0) {
        return s;
    }

    var start: Int = 0;
    var end: Int = s.length - 1;

    // Find first non-space character
    while (start <= end && (s.data[start] == " " || s.data[start] == "\n" || s.data[start] == "\t")) {
        start = start + 1;
    }

    // Find last non-space character
    while (end >= start && (s.data[end] == " " || s.data[end] == "\n" || s.data[end] == "\t")) {
        end = end - 1;
    }

    // Create trimmed string
    let newLength: Int = end - start + 1;
    if (newLength <= 0) {
        return "";
    }

    var str: *Char = alloc_box(newLength);
    memcpy(str, &s.data[start], newLength);
    return createStringFromPointer(str, newLength, true);
}

public func stringReplace(s: String, from: String, to: String) -> String {
    if (from.length == 0 || s.length == 0 || from.length > s.length) {
        return s;
    }

    // Optimized: Count occurrences using memcmp
    let firstChar: Char = from.data[0];
    var count: Int = 0;
    var i: Int = 0;

    while (i <= s.length - from.length) {
        if (s.data[i] == firstChar) {
            if (from.length == 1 || memcmp(&s.data[i], from.data, from.length) == 0) {
                count = count + 1;
                i = i + from.length;
            } else {
                i = i + 1;
            }
        } else {
            i = i + 1;
        }
    }

    // If no occurrences, return original
    if (count == 0) {
        return s;
    }

    let newLength: Int = s.length - (count * from.length) + (count * to.length);

    // Handle case where result would be empty
    if (newLength == 0) {
        return "";
    }

    var str: *Char = alloc_box(newLength);

    i = 0;
    var resultPos: Int = 0;
    while (i < s.length) {
        // Check if we have a match at current position
        var match: Bool = false;
        if (i <= s.length - from.length) {
            if (s.data[i] == firstChar) {
                if (from.length == 1 || memcmp(&s.data[i], from.data, from.length) == 0) {
                    match = true;
                }
            }
        }

        if (match) {
            // Copy 'to' string using memcpy if possible
            if (to.length > 0) {
                memcpy(&str[resultPos], to.data, to.length);
            }
            resultPos = resultPos + to.length;
            i = i + from.length;
        } else {
            // Copy original character
            str[resultPos] = s.data[i];
            resultPos = resultPos + 1;
            i = i + 1;
        }
    }

    return createStringFromPointer(str, newLength, true);
}

public func stringToInt(s: String) -> Int {
    let nullTerminated: *Char = createNullTerminatedCopy(s);
    let result: Int = atoi(nullTerminated);

    deallocate(nullTerminated);
    return result;
}

public func stringToFloat(s: String) -> Float {
    let nullTerminated: *Char = createNullTerminatedCopy(s);
    let result: Float = atof(nullTerminated);

    deallocate(nullTerminated);
    return result;
}

public func intToString(n: Int) -> String {
    let length: Int = snprintf(null, 0, "%d", n);
    let buffer: *Char = alloc_box(length + 1);

    snprintf(buffer, length + 1, "%d", n);
    return createStringFromPointer(buffer, length, true);
}

public func floatToString(f: Float) -> String {
    let length: Int = snprintf(null, 0, "%f", f);
    var buffer: *Char = alloc_box(length + 1);

    snprintf(buffer, length + 1, "%f", f);
    return createStringFromPointer(buffer, length, true);
}
