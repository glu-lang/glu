import allocation::allocate;
import io;

@no_mangling func strlen(s: *Char) -> Int;
@no_mangling func strcat(destination: *Char, source: *Char) -> *Char;
@no_mangling func memcpy(dst: *Char, src: *Char, n: Int) -> *Char;

func createStringFromPointer(s: *Char) -> String {
    var str: String;

    str.data = s;
    str.length = strlen(s);
    str.isAllocated = false;

    return str;
}

public func stringLength(s: String) -> Int {
    return s.length;
}

public func +(lhs: String, rhs: String) -> String {
    var result: String;

    result.data = allocate(lhs.length + rhs.length);

    memcpy(result.data, lhs.data, lhs.length);
    memcpy(&result.data[lhs.length as UInt64], rhs.data, rhs.length);

    result.length = lhs.length + rhs.length;
    result.isAllocated = true;
    return result;
}

// stringIsEmpty(str) → 길이 0 여부
public func stringIsEmpty(s: String) -> Bool {
    return s.length == 0;
}
// ==
public func ==(lhs: String, rhs: String) -> Bool {
    if (lhs.length != rhs.length) {
        return false;
    }
    var i: Int = 0;
    while (i < lhs.length) {
        // (lhs.data as UInt8) + 1;
        // if (*(lhs.data + (i as UInt64)) != *(rhs.data + (i as UInt64))) {
        //     return false;
        // }
        i = i + 1;
    }
    return true;
}

public func ==(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) == (rhs as UInt8);
}

public func !=(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) != (rhs as UInt8);
}

public func <=(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) <= (rhs as UInt8);
}

// stringCompare(a, b) → 사전순 비교 (음수, 0, 양수 반환)

// stringCharAt(str, index) → 특정 인덱스 문자 가져오기
// stringSubstring(str, start, end) → 구간 잘라내기
// stringSlice(str, start, length) → 길이 기반 잘라내기

// stringIndexOf(str, substr) → 부분 문자열 첫 위치
// stringLastIndexOf(str, substr) → 마지막 위치
// stringContains(str, substr) → 포함 여부

// String reverse
public func stringReverse(s: String) -> String {
    var result: String;
    result.data = allocate(s.length);
    var i: Int = 0;
    while (i < s.length) {
        result.data[i as UInt64] = s.data[(s.length - i - 1) as UInt64];
        i = i + 1;
    }
    result.length = s.length;
    result.isAllocated = true;
    return result;
}

// stringToUpper(str) / stringToLower(str)
public func stringToUpper(s: String) -> String {
    var result: String;
    result.data = allocate(s.length);
    var i: Int = 0;
    while (i < s.length) {
        var c: Char = s.data[i as UInt64];
        if ("a" <= c && c <= "z") {
            c = ((c as UInt8) - 32) as Char;
        }
        result.data[i as UInt64] = c;
        i = i + 1;
    }
    result.length = s.length;
    result.isAllocated = true;
    return result;
}

public func stringToLower(s: String) -> String {
    var result: String;
    result.data = allocate(s.length);
    var i: Int = 0;
    while (i < s.length) {
        var c: Char = s.data[i as UInt64];
        if ("A" <= c && c <= "Z") {
            c = ((c as UInt8) + 32) as Char;
        }
        result.data[i as UInt64] = c;
        i = i + 1;
    }
    result.length = s.length;
    result.isAllocated = true;
    return result;
}

// stringTrim(str) → 앞뒤 공백 제거
public func stringTrim(s: String) -> String {
    var start: Int = 0;
    var end: Int = s.length - 1;

    // Find first non-space character
    while (start <= end && (s.data[start as UInt64] == " " || (s.data[start as UInt64] as UInt8) == 10 || (s.data[start as UInt64] as UInt8) == 9)) {
        start = start + 1;
    }

    // Find last non-space character
    while (end >= start && (s.data[end as UInt64] == " " || (s.data[end as UInt64] as UInt8) == 10 || (s.data[end as UInt64] as UInt8) == 9)) {
        end = end - 1;
    }

    // Create trimmed string
    var result: String;
    var newLength: Int = end - start + 1;
    if (newLength < 0) {
        newLength = 0;
    }
    result.data = allocate(newLength);
    memcpy(result.data, &s.data[start as UInt64], newLength);
    result.length = newLength;
    result.isAllocated = true;

    return result;
}

// stringReplace(str, from, to)
public func stringReplace(s: String, from: String, to: String) -> String {
    var result: String;

    // If from string is empty, return original string
    if (from.length == 0) {
        result.data = allocate(s.length);
        memcpy(result.data, s.data, s.length);
        result.length = s.length;
        result.isAllocated = true;
        return result;
    }

    // Count occurrences of 'from' in string
    var count: Int = 0;
    var i: Int = 0;
    while (i <= s.length - from.length) {
        var match: Bool = true;
        var j: Int = 0;
        while (j < from.length) {
            var sChar: Char = s.data[(i + j) as UInt64] as Char;
            var fromChar: Char = from.data[j as UInt64] as Char;
            if (sChar != fromChar) {
                match = false;
                break;
            }
            j = j + 1;
        }
        if (match) {
            count = count + 1;
            i = i + from.length;
        } else {
            i = i + 1;
        }
    }

    // Calculate new length
    var newLength: Int = s.length - (count * from.length) + (count * to.length);

    // Allocate memory for result
    result.data = allocate(newLength);
    result.length = newLength;
    result.isAllocated = true;

    // Copy characters and replace
    i = 0;
    var resultPos: Int = 0;
    while (i < s.length) {
        // Check if we have a match at current position
        var match: Bool = false;
        if (i <= s.length - from.length) {
            match = true;
            var j: Int = 0;
            while (j < from.length) {
                var sChar: Char = s.data[(i + j) as UInt64] as Char;
                var fromChar: Char = from.data[j as UInt64] as Char;
                if (sChar != fromChar) {
                    match = false;
                    break;
                }
                j = j + 1;
            }
        }

        if (match) {
            // Copy 'to' string
            var k: Int = 0;
            while (k < to.length) {
                result.data[(resultPos + k) as UInt64] = to.data[k as UInt64];
                k = k + 1;
            }
            resultPos = resultPos + to.length;
            i = i + from.length;
        } else {
            // Copy original character
            result.data[resultPos as UInt64] = s.data[i as UInt64];
            resultPos = resultPos + 1;
            i = i + 1;
        }
    }

    return result;
}

// stringToInt(str)
// stringToFloat(str)

// intToString(num)
public func intToString(n: Int) -> String {
    var str: String;
    var num: Int = n;
    var isNegative: Bool = n < 0;

    if (isNegative) {
        num = -n;
    }

    // Special case: 0
    if (n == 0) {
        str.data = allocate(1);
        str.data[0] = "0";
        str.length = 1;
        str.isAllocated = true;
        return str;
    }

    // Calculate number of digits
    var nLength: Int = 0;
    var temp: Int = num;
    while (temp > 0) {
        nLength = nLength + 1;
        temp = temp / 10;
    }


    // Allocate memory
    var totalLength: Int = nLength;
    if (isNegative) {
        totalLength = totalLength + 1;
    }
    str.data = allocate(totalLength);
    str.length = totalLength;
    str.isAllocated = true;

    // Add negative sign
    if (isNegative) {
        str.data[0] = "-";
    }

    // Fill digits from right to left
    var i = 0;
    while (i < nLength) {
        str.data[(totalLength - i - 1) as UInt64] = ((num % 10 + 48) as UInt8) as Char;
        num = num / 10;
        i = i + 1;
    }

    return str;
}

// floatToString(num)
