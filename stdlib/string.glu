import allocation::allocate;
import io;

@no_mangling func strlen(s: *Char) -> Int;
@no_mangling func strcat(destination: *Char, source: *Char) -> *Char;
@no_mangling func memcpy(dst: *Char, src: *Char, n: Int) -> *Char;

func createStringFromPointer(s: *Char) -> String {
    var str: String;

    str.data = s;
    str.length = strlen(s);
    str.isAllocated = false;

    return str;
}

public func stringLength(s: String) -> Int {
    return s.length;
}

public func +(lhs: String, rhs: String) -> String {
    var result: String;

    result.data = allocate(lhs.length + rhs.length);

    memcpy(result.data, lhs.data, lhs.length);
    memcpy(&result.data[lhs.length as UInt64], rhs.data, rhs.length);

    result.length = lhs.length + rhs.length;
    result.isAllocated = true;
    return result;
}

// stringIsEmpty(str) → 길이 0 여부
public func stringIsEmpty(s: String) -> Bool {
    return s.length == 0;
}
// ==
public func ==(lhs: String, rhs: String) -> Bool {
    if (lhs.length != rhs.length) {
        return false;
    }
    var i: Int = 0;
    while (i < lhs.length) {
        // (lhs.data as UInt8) + 1;
        // if (*(lhs.data + (i as UInt64)) != *(rhs.data + (i as UInt64))) {
        //     return false;
        // }
        i = i + 1;
    }
    return true;
}

// stringCompare(a, b) → 사전순 비교 (음수, 0, 양수 반환)

// stringCharAt(str, index) → 특정 인덱스 문자 가져오기
// stringSubstring(str, start, end) → 구간 잘라내기
// stringSlice(str, start, length) → 길이 기반 잘라내기

// stringIndexOf(str, substr) → 부분 문자열 첫 위치
// stringLastIndexOf(str, substr) → 마지막 위치
// stringContains(str, substr) → 포함 여부

// String reverse
// stringToUpper(str) / stringToLower(str)
// stringTrim(str) → 앞뒤 공백 제거
// stringReplace(str, from, to)

// stringToInt(str) / stringToFloat(str)
// intToString(num) / floatToString(num)
public func intToString(n: Int) -> String {
    var str: String;
    var nLength: Int = 0;
    var isNegative: Bool = false;
    var num: Int = n;

    if (n < 0) {
        isNegative = true;
        num = -1 * n;
    }

    io::print("intToString isNegative: ");
    io::printLine(isNegative);

    // get nLength
    var temp: Int = n;
    if (temp == 0) {
        nLength = 1;
    } else {
        while (temp != 0) {
            nLength = nLength + 1;
            temp = temp / 10;
        }
    }

    var totalLength: Int = nLength;
    if (isNegative) {
        totalLength = totalLength + 1;
    }

    str.data = allocate(totalLength);
    str.length = totalLength;
    str.isAllocated = true;

    var i = 0;
    while (i != totalLength) {
        if (i == 0 && isNegative) {
            str.data[0] = "-";
        } else {
            var digit: Int = num % 10;
            io::print("Test: ");
            str.data[(totalLength - 1 - i) as UInt64] = (((digit + 48) as UInt8) as Char);
            io::print("intToString digit: ");
            io::printLine(digit);
            num = num / 10;
        }
        io::print("intToString i: ");
        io::printLine(i);

        i = i + 1;

    return str;
}
