import allocation::allocate;

@no_mangling func strlen(s: *Char) -> Int;
@no_mangling func strcat(destination: *Char, source: *Char) -> *Char;
@no_mangling func memcpy(dst: *Char, src: *Char, n: Int) -> *Char;

func createStringFromPointer(s: *Char) -> String {
    var str: String;

    str.data = s;
    str.length = strlen(s);
    str.isAllocated = false;

    return str;
}

public func stringLength(s: String) -> Int {
    return s.length;
}

public func +(lhs: String, rhs: String) -> String {
    var result: String;

    result.data = allocate(lhs.length + rhs.length);

    memcpy(result.data, lhs.data, lhs.length);
    memcpy(&result.data[lhs.length as UInt64], rhs.data, rhs.length);

    result.length = lhs.length + rhs.length;
    result.isAllocated = true;
    return result;
}

public func stringIsEmpty(s: String) -> Bool {
    return s.length == 0;
}

public func ==(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) == (rhs as UInt8);
}

public func !=(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) != (rhs as UInt8);
}

public func <=(lhs: Char, rhs: Char) -> Bool {
    return (lhs as UInt8) <= (rhs as UInt8);
}

public func stringCompare(lhs: String, rhs: String) -> Int {
    var minLength: Int = lhs.length;
    if (rhs.length < minLength) {
        minLength = rhs.length;
    }

    var i: Int = 0;
    while (i < minLength) {
        var lhsChar: Char = lhs.data[i as UInt64];
        var rhsChar: Char = rhs.data[i as UInt64];
        if (lhsChar != rhsChar) {
            return ((lhsChar as UInt8) as Int) - ((rhsChar as UInt8) as Int);
        }
        i = i + 1;
    }

    return lhs.length - rhs.length;
}

public func stringSubstring(s: String, start: Int, end: Int) -> String {
    var result: String;
    if (start < 0 || end < start || end > s.length) {
        result.data = allocate(0);
        result.length = 0;
        result.isAllocated = true;
        return result;
    }
    var length: Int = end - start;
    result.data = allocate(length);
    memcpy(result.data, &s.data[start as UInt64], length);
    result.length = length;
    result.isAllocated = true;
    return result;
}

public func stringCharAt(s: String, index: Int) -> Char {
    if (index < 0 || s.length <= index) {
        return (0 as UInt8) as Char;
    }
    return s.data[index as UInt64] as Char;
}

public func stringSlice(s: String, start: Int, length: Int) -> String {
    var result: String;
    if (start < 0 || length < 0 || start >= s.length) {
        result.data = allocate(0);
        result.length = 0;
        result.isAllocated = true;
        return result;
    }
    var actualLength: Int = length;
    if (start + length > s.length) {
        actualLength = s.length - start;
    }
    result.data = allocate(actualLength);
    memcpy(result.data, &s.data[start as UInt64], actualLength);
    result.length = actualLength;
    result.isAllocated = true;
    return result;
}

public func stringIndexOf(s: String, substr: String) -> Int {
    if (substr.length == 0) {
        return 0;
    }
    if (s.length < substr.length) {
        return -(1 as Int);
    }

    var i: Int = 0;
    while (i <= s.length - substr.length) {
        var match: Bool = true;
        var j: Int = 0;
        while (j < substr.length) {
            var sChar: Char = s.data[(i + j) as UInt64] as Char;
            var subChar: Char = substr.data[j as UInt64] as Char;
            if (sChar != subChar) {
                match = false;
                break;
            }
            j = j + 1;
        }
        if (match) {
            return i;
        }
        i = i + 1;
    }
    return -(1 as Int);
}

public func stringLastIndexOf(s: String, substr: String) -> Int {
    if (substr.length == 0) {
        return s.length;
    }
    if (s.length < substr.length) {
        return -(1 as Int);
    }

    var i: Int = s.length - substr.length;
    while (i >= 0) {
        var match: Bool = true;
        var j: Int = 0;
        while (j < substr.length) {
            var sChar: Char = s.data[(i + j) as UInt64] as Char;
            var subChar: Char = substr.data[j as UInt64] as Char;
            if (sChar != subChar) {
                match = false;
                break;
            }
            j = j + 1;
        }
        if (match) {
            return i;
        }
        i = i - 1;
    }
    return -(1 as Int);
}

public func stringContains(s: String, substr: String) -> Bool {
    if (substr.length == 0) {
        return true;
    }
    if (s.length < substr.length) {
        return false;
    }

    var i: Int = 0;
    while (i <= s.length - substr.length) {
        var match: Bool = true;
        var j: Int = 0;
        while (j < substr.length) {
            var sChar: Char = s.data[(i + j) as UInt64] as Char;
            var subChar: Char = substr.data[j as UInt64] as Char;
            if (sChar != subChar) {
                match = false;
                break;
            }
            j = j + 1;
        }
        if (match) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

public func stringReverse(s: String) -> String {
    var result: String;
    result.data = allocate(s.length);
    var i: Int = 0;
    while (i < s.length) {
        result.data[i as UInt64] = s.data[(s.length - i - 1) as UInt64];
        i = i + 1;
    }
    result.length = s.length;
    result.isAllocated = true;
    return result;
}

public func stringToUpper(s: String) -> String {
    var result: String;
    result.data = allocate(s.length);
    var i: Int = 0;
    while (i < s.length) {
        var c: Char = s.data[i as UInt64];
        if ("a" <= c && c <= "z") {
            c = ((c as UInt8) - 32) as Char;
        }
        result.data[i as UInt64] = c;
        i = i + 1;
    }
    result.length = s.length;
    result.isAllocated = true;
    return result;
}

public func stringToLower(s: String) -> String {
    var result: String;
    result.data = allocate(s.length);
    var i: Int = 0;
    while (i < s.length) {
        var c: Char = s.data[i as UInt64];
        if ("A" <= c && c <= "Z") {
            c = ((c as UInt8) + 32) as Char;
        }
        result.data[i as UInt64] = c;
        i = i + 1;
    }
    result.length = s.length;
    result.isAllocated = true;
    return result;
}

public func stringTrim(s: String) -> String {
    var start: Int = 0;
    var end: Int = s.length - 1;

    // Find first non-space character
    while (start <= end && (s.data[start as UInt64] == " " || (s.data[start as UInt64] as UInt8) == 10 || (s.data[start as UInt64] as UInt8) == 9)) {
        start = start + 1;
    }

    // Find last non-space character
    while (end >= start && (s.data[end as UInt64] == " " || (s.data[end as UInt64] as UInt8) == 10 || (s.data[end as UInt64] as UInt8) == 9)) {
        end = end - 1;
    }

    // Create trimmed string
    var result: String;
    var newLength: Int = end - start + 1;
    if (newLength < 0) {
        newLength = 0;
    }
    result.data = allocate(newLength);
    memcpy(result.data, &s.data[start as UInt64], newLength);
    result.length = newLength;
    result.isAllocated = true;

    return result;
}

public func stringReplace(s: String, from: String, to: String) -> String {
    var result: String;

    // If from string is empty, return original string
    if (from.length == 0) {
        result.data = allocate(s.length);
        memcpy(result.data, s.data, s.length);
        result.length = s.length;
        result.isAllocated = true;
        return result;
    }

    // Count occurrences of 'from' in string
    var count: Int = 0;
    var i: Int = 0;
    while (i <= s.length - from.length) {
        var match: Bool = true;
        var j: Int = 0;
        while (j < from.length) {
            var sChar: Char = s.data[(i + j) as UInt64] as Char;
            var fromChar: Char = from.data[j as UInt64] as Char;
            if (sChar != fromChar) {
                match = false;
                break;
            }
            j = j + 1;
        }
        if (match) {
            count = count + 1;
            i = i + from.length;
        } else {
            i = i + 1;
        }
    }

    // Calculate new length
    var newLength: Int = s.length - (count * from.length) + (count * to.length);

    // Allocate memory for result
    result.data = allocate(newLength);
    result.length = newLength;
    result.isAllocated = true;

    // Copy characters and replace
    i = 0;
    var resultPos: Int = 0;
    while (i < s.length) {
        // Check if we have a match at current position
        var match: Bool = false;
        if (i <= s.length - from.length) {
            match = true;
            var j: Int = 0;
            while (j < from.length) {
                var sChar: Char = s.data[(i + j) as UInt64] as Char;
                var fromChar: Char = from.data[j as UInt64] as Char;
                if (sChar != fromChar) {
                    match = false;
                    break;
                }
                j = j + 1;
            }
        }

        if (match) {
            // Copy 'to' string
            var k: Int = 0;
            while (k < to.length) {
                result.data[(resultPos + k) as UInt64] = to.data[k as UInt64];
                k = k + 1;
            }
            resultPos = resultPos + to.length;
            i = i + from.length;
        } else {
            // Copy original character
            result.data[resultPos as UInt64] = s.data[i as UInt64];
            resultPos = resultPos + 1;
            i = i + 1;
        }
    }

    return result;
}

// stringToInt(str)
public func stringToInt(s: String) -> Int {
    var i: Int = 0;
    var result: Int = 0;
    var isNegative: Bool = false;

    // Skip leading whitespace
    while (i < s.length && (s.data[i as UInt64] == " " || (s.data[i as UInt64] as UInt8) == 10 || (s.data[i as UInt64] as UInt8) == 9)) {
        i = i + 1;
    }

    // Check for optional sign
    if (i < s.length) {
        if (s.data[i as UInt64] == "-") {
            isNegative = true;
            i = i + 1;
        } else if (s.data[i as UInt64] == "+") {
            i = i + 1;
        }
    }

    // Convert digits to integer
    while (i < s.length) {
        var c: Char = s.data[i as UInt64];
        if (c < "0" || c > "9") {
            break;
        }
        result = result * 10 + ((c as UInt8) - 48) as Int;
        i = i + 1;
    }

    if (isNegative) {
        result = -result;
    }

    return result;
}
// stringToFloat(str)

// intToString(num)
public func intToString(n: Int) -> String {
    var str: String;
    var num: Int = n;
    var isNegative: Bool = n < 0;

    if (isNegative) {
        num = -n;
    }

    // Special case: 0
    if (n == 0) {
        str.data = allocate(1);
        str.data[0] = "0";
        str.length = 1;
        str.isAllocated = true;
        return str;
    }

    // Calculate number of digits
    var nLength: Int = 0;
    var temp: Int = num;
    while (temp > 0) {
        nLength = nLength + 1;
        temp = temp / 10;
    }


    // Allocate memory
    var totalLength: Int = nLength;
    if (isNegative) {
        totalLength = totalLength + 1;
    }
    str.data = allocate(totalLength);
    str.length = totalLength;
    str.isAllocated = true;

    // Add negative sign
    if (isNegative) {
        str.data[0] = "-";
    }

    // Fill digits from right to left
    var i = 0;
    while (i < nLength) {
        str.data[(totalLength - i - 1) as UInt64] = ((num % 10 + 48) as UInt8) as Char;
        num = num / 10;
        i = i + 1;
    }

    return str;
}

// floatToString(num)
